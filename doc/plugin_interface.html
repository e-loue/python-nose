<html>
  <head>
    <title>nose: Plugin Interface</title>
    <link rel="stylesheet" href="site.css" type="text/css"></link>
  </head>
  <body>
    
    <div id="menu">
      <p>This document covers nose version <b>0.10.0a1</b></p>
      FIXME -- menu
      <p>Last update: <b>Tue Jun 12 23:51:50 2007</b></p>
    </div>
    
    <div id="main">
      <h1>Plugin Interface</h1>
      
      <p>While it is recommended that plugins subclass
nose.plugins.Plugin, the only requirements for a plugin are
that it implement the methods <cite>options(self, parser, env)</cite> and
<cite>configure(self, options, conf)</cite>, and have the attributes
<cite>enabled</cite>, <cite>name</cite> and <cite>score</cite>.</p>
<p>Plugins may implement any or all of the methods documented
below. Please note that they <em>must not</em> subclass <cite>IPluginInterface</cite>;
<cite>IPluginInterface</cite> is a only description of the plugin API.</p>
<p>When plugins are called, the first plugin that implements a method
and returns a non-None value wins, and plugin processing ends. The
exceptions to this are methods marked as <cite>generative</cite> or
<cite>chainable</cite>.  <cite>generative</cite> methods combine the output of all
plugins that respond with an iterable into a single flattened
iterable response (a generator, really). <cite>chainable</cite> methods pass
the results of calling plugin A as the input to plugin B, where
the positions in the chain are determined by the plugin sort
order, which is in order by <cite>score</cite> descending.</p>
<p>In general, plugin methods correspond directly to methods of
<cite>nose.selector.Selector</cite>, <cite>nose.loader.TestLoader</cite> and
<cite>nose.result.TextTestResult</cite> are called by those methods when they are
called. In some cases, the plugin hook doesn't neatly match the
method in which it is called; for those, the documentation for the
hook will tell you where in the test process it is called.</p>
<p>Plugin hooks fall into four broad categories: selecting and
loading tests, handling errors raised by tests, preparing objects
used in the testing process, and watching and reporting on test
results.</p>
<div class="section">
<h1><a id="selecting-and-loading-tests" name="selecting-and-loading-tests">Selecting and loading tests</a></h1>
<p>To alter test selection behavior, implement any necessary <cite>want*</cite>
methods as outlined below. Keep in mind, though, that when your
plugin returns True from a <cite>want*</cite> method, you will send the requested
object through the normal test collection process. If the object
represents something from which normal tests can't be collected, you
must also implement a loader method to load the tests.</p>
<p>Examples:</p>
<ul class="simple">
<li>The builtin doctests plugin implements <cite>wantFile</cite> to enable
loading of doctests from files that are not python modules. It
also implements <cite>loadTestsFromModule</cite> to load doctests from
python modules, and <cite>loadTestsFromFile</cite> to load tests from the
non-module files selected by <cite>wantFile</cite>.</li>
<li>The builtin attrib plugin implements <cite>wantFunction</cite> and
<cite>wantMethod</cite> so that it can reject tests that don't match the
specified attributes.</li>
</ul>
</div>
<div class="section">
<h1><a id="handling-errors" name="handling-errors">Handling errors</a></h1>
<p>FIXME describe ErrorClass plugins</p>
<p>Examples:</p>
<ul class="simple">
<li>The builtin skip and deprecated plugins are ErrorClass plugins.</li>
</ul>
</div>
<div class="section">
<h1><a id="preparing-test-objects" name="preparing-test-objects">Preparing test objects</a></h1>
<p>To alter, get a handle on, or replace test framework objects such
as the loader, result, runner, and test cases, use the appropriate
prepare methods. The simplest reason to use prepare is if you need
to use an object yourself. For example, the isolate plugin
implements <cite>prepareTestLoader</cite> so that it can use the test loader
later on to load tests. If you return a value from a prepare
method, that value will be used in place of the loader, result,
runner or test case, respectively. When replacing test cases, be
aware that you are replacing the entire test case -- including the
whole <cite>run(result)</cite> method of the <cite>unittest.TestCase</cite> -- so if you
want normal unittest test result reporting, you must implement the
same calls to result as <cite>unittest.TestCase.run</cite>.</p>
<p>Examples:</p>
<ul class="simple">
<li>The builtin isolate plugin implements <cite>prepareTestLoader</cite> but
does not replace the test loader.</li>
<li>The builtin profile plugin implements <cite>prepareTest</cite> and does
replace the top-level test case by returning the case wrapped in
the profiler function.</li>
</ul>
</div>
<div class="section">
<h1><a id="watching-or-reporting-on-tests" name="watching-or-reporting-on-tests">Watching or reporting on tests</a></h1>
<p>To record information about tests or other modules imported during
the testing process, output additional reports, or entirely change
test report output, implement any of the methods outlined below that
correspond to TextTestResult methods.</p>
<p>Examples:</p>
<ul class="simple">
<li>The builtin cover plugin implements <cite>begin</cite> and <cite>report</cite> to
capture and report code coverage metrics for all or selected modules
loaded during testing.</li>
<li>The builtin profile plugin implements <cite>begin</cite>, <cite>prepareTest</cite> and
<cite>report</cite> to record and output profiling information. In this
case, the plugin's <cite>prepareTest</cite> method constructs a function that
runs the test through the hotshot profiler's runcall() method.</li>
</ul>
</div>


      <h2>Plugin Interface Methods</h2>

      <p>Plugin interface methods are described below, in alphabetical
	order. Methods that are <span class="method new">new</span> in
	this release are <span class="method new">highlighted</span>. 
	<span class="method deprecated">Deprecated methods</span> are
	struck through. Methods that may be generators are labeled
	with the icon FIXME. Methods that are chainable (that is, the
	results of calling the method on one plugin are passed as
	input to the next plugin) are labeled with the icon FIXME.</p>

      
<div class="method deprecated">
<span class="name">addDeprecated</span><span class="arg">(self, test)</span>
<div class="doc"><p>Called when a deprecated test is seen. DO NOT return a value
unless you want to stop other plugins from seeing the deprecated
test.</p>
<p>DEPRECATED -- check error class in addError instead</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt>test <span class="classifier-delimiter">:</span> <span class="classifier"><cite>nose.case.Test</cite></span></dt>
<dd><p class="first last">the test case</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</div>
</div>

<div class="method changed">
<span class="name">addError</span><span class="arg">(self, test, err)</span>
<div class="doc"><p>Called when a test raises an uncaught exception. DO NOT return a
value unless you want to stop other plugins from seeing that the
test has raised an error.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt>test <span class="classifier-delimiter">:</span> <span class="classifier"><cite>nose.case.Test</cite></span></dt>
<dd><p class="first last">the test case</p>
</dd>
<dt>err <span class="classifier-delimiter">:</span> <span class="classifier">3-tuple</span></dt>
<dd><p class="first last">sys.exc_info() tuple</p>
</dd>
<dt>capt <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first">Captured output, if any</p>
<div class="last note">
<p class="first admonition-title">Note</p>
<p class="last">DEPRECATED: this parameter will not be passed</p>
</div>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</div>
</div>

<div class="method changed">
<span class="name">addFailure</span><span class="arg">(self, test, err)</span>
<div class="doc"><p>Called when a test fails. DO NOT return a value unless you
want to stop other plugins from seeing that the test has failed.</p>
<dl class="docutils">
<dt>Parameters:</dt>
<dd><ul class="first last simple">
<li>test:
the test case</li>
<li>err:
sys.exc_info() tuple</li>
<li>capt:
Captured output, if any.
DEPRECATED: this parameter will not be passed</li>
<li>tb_info:
Introspected traceback info, if any
DEPRECATED: this parameter will not be passed</li>
</ul>
</dd>
</dl>
</div>
</div>

<div class="method deprecated">
<span class="name">addOptions</span><span class="arg">(self, parser, env=os.environ)</span>
<div class="doc"><p>Called to allow plugin to register command line
options with the parser.</p>
<p>Do <em>not</em> return a value from this method unless you want to stop
all other plugins from setting their options.</p>
<p>DEPRECATED -- implement <cite>options</cite> instead.</p>
</div>
</div>

<div class="method deprecated">
<span class="name">addSkip</span><span class="arg">(self, test)</span>
<div class="doc"><p>Called when a test is skipped. DO NOT return a value unless
you want to stop other plugins from seeing the skipped test.</p>
<p>DEPRECATED -- check error class in addError instead</p>
<dl class="docutils">
<dt>Parameters:</dt>
<dd><ul class="first last simple">
<li>test:
the test case</li>
</ul>
</dd>
</dl>
</div>
</div>

<div class="method ">
<span class="name">addSuccess</span><span class="arg">(self, test, capt)</span>
<div class="doc"><p>Called when a test passes. DO NOT return a value unless you
want to stop other plugins from seeing the passing test.</p>
<dl class="docutils">
<dt>Parameters:</dt>
<dd><ul class="first last simple">
<li>test:
the test case</li>
<li>capt:
Captured output, if any.</li>
</ul>
</dd>
</dl>
</div>
</div>

<div class="method deprecated">
<span class="name">add_options</span><span class="arg">(self, parser, env=os.environ)</span>
<div class="doc"><p>Called to allow plugin to register command line
options with the parser.</p>
<p>Do <em>not</em> return a value from this method unless you want to stop
all other plugins from setting their options.</p>
<p>DEPRECATED -- implement <cite>options</cite> instead.</p>
</div>
</div>

<div class="method new">
<span class="name">afterContext</span><span class="arg">(self)</span>
<div class="doc"><p>Called after a context (generally a module) has been
lazy-loaded, imported, setup, had its tests loaded and
executed, and torn down.</p>
</div>
</div>

<div class="method new">
<span class="name">afterDirectory</span><span class="arg">(self, path)</span>
<div class="doc"><p>Called after all tests have been loaded from directory at path
and run.</p>
<dl class="docutils">
<dt>Parameters:</dt>
<dd><ul class="first last simple">
<li>path
the directory that has finished processing</li>
</ul>
</dd>
</dl>
</div>
</div>

<div class="method new">
<span class="name">afterImport</span><span class="arg">(self, filename, module)</span>
<div class="doc"><p>Called after module is imported from filename. afterImport
is called even if the import failed.</p>
<dl class="docutils">
<dt>Parameters:</dt>
<dd><ul class="first last simple">
<li>filename:
The file that was loaded</li>
<li>module:
The name of the module</li>
</ul>
</dd>
</dl>
</div>
</div>

<div class="method new">
<span class="name">afterTest</span><span class="arg">(self, test)</span>
<div class="doc"><p>Called after the test has been run and the result recorded
(after stopTest).</p>
<dl class="docutils">
<dt>Parameters:</dt>
<dd><ul class="first last simple">
<li>test:
the test case</li>
</ul>
</dd>
</dl>
</div>
</div>

<div class="method new">
<span class="name">beforeContext</span><span class="arg">(self)</span>
<div class="doc"><p>Called before a context (generally a module) is
examined. Since the context is not yet loaded, plugins don't
get to know what the context is; so any context operations
should use a stack that is pushed in <cite>beforeContext</cite> and popped
in <cite>afterContext</cite> to ensure they operate symmetrically.</p>
<p><cite>beforeContext</cite> and <cite>afterContext</cite> are mainly
useful for tracking and restoring global state around possible
changes from within a context, whatever the context may be. If
you need to operate on contexts themselves, see <cite>startContext</cite>
and <cite>stopContext</cite>, which are passed the context in question, but
are called after it has been loaded (imported in the module
case).</p>
</div>
</div>

<div class="method new">
<span class="name">beforeDirectory</span><span class="arg">(self, path)</span>
<div class="doc"><p>Called before tests are loaded from directory at path.</p>
<dl class="docutils">
<dt>Parameters:</dt>
<dd><ul class="first last simple">
<li>path:
the directory that is about to be processed</li>
</ul>
</dd>
</dl>
</div>
</div>

<div class="method new">
<span class="name">beforeImport</span><span class="arg">(self, filename, module)</span>
<div class="doc"><p>Called before module is imported from filename.</p>
<dl class="docutils">
<dt>Parameters:</dt>
<dd><ul class="first last simple">
<li>filename
The file that will be loaded</li>
<li>module
The name of the module found in file</li>
</ul>
</dd>
</dl>
</div>
</div>

<div class="method new">
<span class="name">beforeTest</span><span class="arg">(self, test)</span>
<div class="doc"><p>Called before the test is run (before startTest).</p>
<dl class="docutils">
<dt>Parameters:</dt>
<dd><ul class="first last simple">
<li>test:
the test case</li>
</ul>
</dd>
</dl>
</div>
</div>

<div class="method ">
<span class="name">begin</span><span class="arg">(self)</span>
<div class="doc"><p>Called before any tests are collected or run. Use this to
perform any setup needed before testing begins.</p>
</div>
</div>

<div class="method ">
<span class="name">configure</span><span class="arg">(self, options, conf)</span>
<div class="doc"><p>Called after the command line has been parsed, with the
parsed options and the config container. Here, implement any
config storage or changes to state or operation that are set
by command line options.</p>
<p>Do <em>not</em> return a value from this method unless you want to
stop all other plugins from being configured.</p>
</div>
</div>

<div class="method new">
<span class="name">describeTest</span><span class="arg">(self, test)</span>
<div class="doc"><p>Return a test description. Called by
<cite>nose.case.Test.shortDescription</cite>.</p>
<dl class="docutils">
<dt>Parameters:</dt>
<dd><ul class="first last simple">
<li>test:
the test case</li>
</ul>
</dd>
</dl>
</div>
</div>

<div class="method ">
<span class="name">finalize</span><span class="arg">(self, result)</span>
<div class="doc"><p>Called after all report output, including output from all
plugins, has been sent to the stream. Use this to print final
test results or perform final cleanup. Return None to allow
other plugins to continue printing, any other value to stop
them.</p>
</div>
</div>

<div class="method new chainable">
<span class="name">formatError</span><span class="arg">(self, test, err)</span>
<div class="doc"><p>Called in result.addError, before plugin.addError. If you
want to replace or modify the error tuple, return a new error
tuple.</p>
<dl class="docutils">
<dt>Parameters:</dt>
<dd><ul class="first last simple">
<li>test:
the test case</li>
<li>err:
the error tuple (class, value, traceback)</li>
</ul>
</dd>
</dl>
</div>
</div>

<div class="method new chainable">
<span class="name">formatFailure</span><span class="arg">(self, test, err)</span>
<div class="doc"><p>Called in result.addFailure, before plugin.addFailure. If you
want to replace or modify the error tuple, return a new error
tuple.</p>
<dl class="docutils">
<dt>Parameters:</dt>
<dd><ul class="first last simple">
<li>test:
the test case</li>
<li>err:
the error tuple (class, value, traceback)</li>
</ul>
</dd>
</dl>
</div>
</div>

<div class="method new">
<span class="name">handleError</span><span class="arg">(self, test, err)</span>
<div class="doc"><p>Called on addError. To handle the error yourself and prevent normal
error processing, return a true value.</p>
<dl class="docutils">
<dt>Parameters:</dt>
<dd><ul class="first last simple">
<li>test:
the test case</li>
<li>err:
the error tuple (class, value, traceback)</li>
</ul>
</dd>
</dl>
</div>
</div>

<div class="method new">
<span class="name">handleFailure</span><span class="arg">(self, test, err)</span>
<div class="doc"><p>Called on addFailure. To handle the failure yourself and
prevent normal failure processing, return a true value.</p>
<dl class="docutils">
<dt>Parameters:</dt>
<dd><ul class="first last simple">
<li>test:
the test case</li>
<li>err:
the error tuple (class, value, traceback)</li>
</ul>
</dd>
</dl>
</div>
</div>

<div class="method new generative">
<span class="name">loadTestsFromDir</span><span class="arg">(self, path)</span>
<div class="doc"><p>Return iterable of tests from a directory. May be a
generator.  Each item returned must be a runnable
unittest.TestCase (or subclass) instance or suite instance.
Return None if your plugin cannot collect any tests from
directory.</p>
<dl class="docutils">
<dt>Parameters:</dt>
<dd><ul class="first last simple">
<li>path:
The path to the directory.</li>
</ul>
</dd>
</dl>
</div>
</div>

<div class="method new generative">
<span class="name">loadTestsFromFile</span><span class="arg">(self, filename)</span>
<div class="doc"><p>Return tests in this file. Return None if you are not
interested in loading any tests, or an iterable if you are and
can load some. May be a generator. <em>If you are interested in
loading tests from the file and encounter no errors, but find
no tests, yield False or return [False].</em></p>
<p>NOTE that this method replaces loadTestsFromPath from the 0.9
API.</p>
<dl class="docutils">
<dt>Parameters:</dt>
<dd><ul class="first last simple">
<li>filename:
The full path to the file or directory.</li>
</ul>
</dd>
</dl>
</div>
</div>

<div class="method generative">
<span class="name">loadTestsFromModule</span><span class="arg">(self, module)</span>
<div class="doc"><p>Return iterable of tests in a module. May be a
generator. Each item returned must be a runnable
unittest.TestCase (or subclass) instance.
Return None if your plugin cannot
collect any tests from module.</p>
<dl class="docutils">
<dt>Parameters:</dt>
<dd><ul class="first last simple">
<li>module:
The module object</li>
</ul>
</dd>
</dl>
</div>
</div>

<div class="method generative">
<span class="name">loadTestsFromName</span><span class="arg">(self, name, module=None, importPath=None)</span>
<div class="doc"><p>Return tests in this file or module. Return None if you are not able
to load any tests, or an iterable if you are. May be a
generator.</p>
<dl class="docutils">
<dt>Parameters:</dt>
<dd><ul class="first last simple">
<li>name:
The test name. May be a file or module name plus a test
callable. Use split_test_name to split into parts. Or it might
be some crazy name of your own devising, in which case, do
whatever you want.</li>
<li>module:
Module from which the name is to be loaded</li>
<li>importPath:
Path from which file (must be a python module) was found
DEPRECATED: this argument will NOT be passed.</li>
</ul>
</dd>
</dl>
</div>
</div>

<div class="method new chainable">
<span class="name">loadTestsFromNames</span><span class="arg">(self, names, module=None)</span>
<div class="doc"><p>Return a tuple of (tests loaded, remaining names). Return
None if you are not able to load any tests. Multiple plugins
may implement loadTestsFromNames; the remaining name list from
each will be passed to the next as input.</p>
<dl class="docutils">
<dt>Parameters:</dt>
<dd><ul class="first last simple">
<li>names:
List of test names.</li>
<li>module:
Module from which the names are to be loaded</li>
</ul>
</dd>
</dl>
</div>
</div>

<div class="method deprecated">
<span class="name">loadTestsFromPath</span><span class="arg">(self, path)</span>
<div class="doc"><p>DEPRECATED</p>
<p>use loadTestsFromFile instead</p>
</div>
</div>

<div class="method generative">
<span class="name">loadTestsFromTestCase</span><span class="arg">(self, cls)</span>
<div class="doc"><p>Return tests in this test case class. Return None if you are
not able to load any tests, or an iterable if you are. May be a
generator.</p>
<dl class="docutils">
<dt>Parameters:</dt>
<dd><ul class="first last simple">
<li>cls:
The test case class</li>
</ul>
</dd>
</dl>
</div>
</div>

<div class="method new generative">
<span class="name">loadTestsFromTestClass</span><span class="arg">(self, cls)</span>
<div class="doc"><p>Return tests in this test class. Class will <em>not</em> be a
unittest.TestCase subclass. Return None if you are not able to
load any tests, an iterable if you are. May be a generator.</p>
<dl class="docutils">
<dt>Parameters:</dt>
<dd><ul class="first last simple">
<li>cls:
The test class</li>
</ul>
</dd>
</dl>
</div>
</div>

<div class="method new generative">
<span class="name">makeTest</span><span class="arg">(self, obj, parent)</span>
<div class="doc"><p>Given an object and its parent, return a test case. Must be
a unittest.TestCase or TestSuite (or subclass) instance. This
is called before default test loading to allow plugins to load
an alternate test case or cases for an object. May be a generator.</p>
<dl class="docutils">
<dt>Parameters:</dt>
<dd><ul class="first last simple">
<li>obj:
The object to be made into a test</li>
<li>parent:
The parent of obj (eg, for a method, the class)</li>
</ul>
</dd>
</dl>
</div>
</div>

<div class="method ">
<span class="name">prepareTest</span><span class="arg">(self, test)</span>
<div class="doc"><p>Called before the test is run by the test runner. Please
note the article <em>the</em> in the previous sentence: prepareTest
is called <em>only once</em>, and is passed the test case or test
suite that the test runner will execute. It is <em>not</em> called
for each individual test case. If you return a non-None value,
that return value will be run as the test. Use this hook to
wrap or decorate the test with another function. If you need
to modify or wrap individual test cases, use <cite>prepareTestCase</cite>
instead.</p>
<dl class="docutils">
<dt>Parameters:</dt>
<dd><ul class="first last simple">
<li>test:
the test case</li>
</ul>
</dd>
</dl>
</div>
</div>

<div class="method ">
<span class="name">prepareTestCase</span><span class="arg">(self, test)</span>
<div class="doc"><p>Prepare or wrap an individual test case. Called before
execution of the test. The test passed here is a
nose.case.Test instance; the case to be executed is in the
test attribute of the passed case. To modify the test to be
run, you should return a callable that takes one argument (the
test result object) -- it is recommended that you <em>do not</em>
side-effect the nose.case.Test instance you have been passed.</p>
<p>Keep in mind that when you replace the test callable you are
replacing the run() method of the test case -- including the
exception handling and result calls, etc.</p>
<dl class="docutils">
<dt>Parameters:</dt>
<dd><ul class="first last simple">
<li>test:
the test case</li>
</ul>
</dd>
</dl>
</div>
</div>

<div class="method new">
<span class="name">prepareTestLoader</span><span class="arg">(self, loader)</span>
<div class="doc"><p>Called before tests are loaded. To replace the test loader,
return a test loader. To allow other plugins to process the
test loader, return None. Only one plugin may replace the test
loader. Only valid when using nose.TestProgram.</p>
<dl class="docutils">
<dt>Parameters:</dt>
<dd><ul class="first last simple">
<li>loader:
the test loader</li>
</ul>
</dd>
</dl>
</div>
</div>

<div class="method new">
<span class="name">prepareTestResult</span><span class="arg">(self, result)</span>
<div class="doc"><p>Called before the first test is run. To use a different
test result handler for all tests than the given result,
return a test result handler. NOTE however that this handler
will only be seen by tests, that is, inside of the result
proxy system. The TestRunner and TestProgram -- whether nose's
or other -- will continue to see the original result
handler. For this reason, it is usually better to monkeypatch
the result (for instance, if you want to handle TODO
exceptions in some way). Only one plugin may replace the
result, but many may monkeypatch it. If you want to
monkeypatch and stop other plugins from doing so, monkeypatch
and return the patched result.</p>
<dl class="docutils">
<dt>Parameters:</dt>
<dd><ul class="first last simple">
<li>result:
the test result</li>
</ul>
</dd>
</dl>
</div>
</div>

<div class="method new">
<span class="name">prepareTestRunner</span><span class="arg">(self, runner)</span>
<div class="doc"><p>Called before tests are run. To replace the test runner,
return a test runner. To allow other plugins to process the
test runner, return None. Only valid when using nose.TesrProgram.</p>
<dl class="docutils">
<dt>Parameters:</dt>
<dd><ul class="first last simple">
<li>runner
the test runner</li>
</ul>
</dd>
</dl>
</div>
</div>

<div class="method ">
<span class="name">report</span><span class="arg">(self, stream)</span>
<div class="doc"><p>Called after all error output has been printed. Print your
plugin's report to the provided stream. Return None to allow
other plugins to print reports, any other value to stop them.</p>
<dl class="docutils">
<dt>Parameters:</dt>
<dd><ul class="first last simple">
<li>stream:
stream object; send your output here</li>
</ul>
</dd>
</dl>
</div>
</div>

<div class="method ">
<span class="name">setOutputStream</span><span class="arg">(self, stream)</span>
<div class="doc"><p>Called before test output begins. To direct test output to a
new stream, return a stream object, which must implement a
<cite>write(msg)</cite> method. If you only want to note the stream, not
capture or redirect it, then return None.</p>
<dl class="docutils">
<dt>Parameters:</dt>
<dd><ul class="first last simple">
<li>stream:
the original output stream</li>
</ul>
</dd>
</dl>
</div>
</div>

<div class="method new">
<span class="name">startContext</span><span class="arg">(self, context)</span>
<div class="doc"><p>Called before context setup and the running of tests in the
context. Note that tests have already been <em>loaded</em> from the
context before this call.</p>
<dl class="docutils">
<dt>Parameters:</dt>
<dd><ul class="first last simple">
<li>context:
the context about to be setup. May be a module or class, or any
other object that contains tests.</li>
</ul>
</dd>
</dl>
</div>
</div>

<div class="method ">
<span class="name">startTest</span><span class="arg">(self, test)</span>
<div class="doc"><p>Called before each test is run. DO NOT return a value unless
you want to stop other plugins from seeing the test start.</p>
<dl class="docutils">
<dt>Parameters:</dt>
<dd><ul class="first last simple">
<li>test:
the test case</li>
</ul>
</dd>
</dl>
</div>
</div>

<div class="method new">
<span class="name">stopContext</span><span class="arg">(self, context)</span>
<div class="doc"><p>Called after the tests in a context have run and the
context has been torn down.</p>
<dl class="docutils">
<dt>Parameters:</dt>
<dd><ul class="first last simple">
<li>context:
the context that has just been torn down.</li>
</ul>
</dd>
</dl>
</div>
</div>

<div class="method ">
<span class="name">stopTest</span><span class="arg">(self, test)</span>
<div class="doc"><p>Called after each test is run. DO NOT return a value unless
you want to stop other plugins from seeing that the test has stopped.</p>
<dl class="docutils">
<dt>Parameters:</dt>
<dd><ul class="first last simple">
<li>test:
the test case</li>
</ul>
</dd>
</dl>
</div>
</div>

<div class="method new">
<span class="name">testName</span><span class="arg">(self, test)</span>
<div class="doc"><p>Return a short test name. Called by <cite>nose.case.Test.__str__</cite>.</p>
<dl class="docutils">
<dt>Parameters:</dt>
<dd><ul class="first last simple">
<li>test:
the test case</li>
</ul>
</dd>
</dl>
</div>
</div>

<div class="method ">
<span class="name">wantClass</span><span class="arg">(self, cls)</span>
<div class="doc"><p>Return true if you want the main test selector to collect
tests from this class, false if you don't, and None if you don't
care.</p>
<dl class="docutils">
<dt>Parameters:</dt>
<dd><ul class="first last simple">
<li>cls:
The class</li>
</ul>
</dd>
</dl>
</div>
</div>

<div class="method ">
<span class="name">wantDirectory</span><span class="arg">(self, dirname)</span>
<div class="doc"><p>Return true if you want test collection to descend into this
directory, false if you do not, and None if you don't care.</p>
<dl class="docutils">
<dt>Parameters:</dt>
<dd><ul class="first last simple">
<li>dirname:
Full path to directory</li>
</ul>
</dd>
</dl>
</div>
</div>

<div class="method ">
<span class="name">wantFile</span><span class="arg">(self, file)</span>
<div class="doc"><p>Return true if you want to collect tests from this file,
false if you do not and None if you don't care.</p>
<p>Change from 0.9: The optional package parameter is no longer passed.</p>
<dl class="docutils">
<dt>Parameters:</dt>
<dd><ul class="first last simple">
<li>file:
Full path to file</li>
</ul>
</dd>
</dl>
</div>
</div>

<div class="method ">
<span class="name">wantFunction</span><span class="arg">(self, function)</span>
<div class="doc"><p>Return true to collect this function as a test, false to
prevent it from being collected, and None if you don't care.</p>
<dl class="docutils">
<dt>Parameters:</dt>
<dd><ul class="first last simple">
<li>function:
The function object</li>
</ul>
</dd>
</dl>
</div>
</div>

<div class="method ">
<span class="name">wantMethod</span><span class="arg">(self, method)</span>
<div class="doc"><p>Return true to collect this method as a test, false to
prevent it from being collected, and None if you don't care.</p>
<dl class="docutils">
<dt>Parameters:</dt>
<dd><ul class="first last simple">
<li>method:
The method object</li>
</ul>
</dd>
</dl>
</div>
</div>

<div class="method ">
<span class="name">wantModule</span><span class="arg">(self, module)</span>
<div class="doc"><p>Return true if you want to collection to descend into this
module, false to prevent the collector from descending into the
module, and None if you don't care.</p>
<dl class="docutils">
<dt>Parameters:</dt>
<dd><ul class="first last simple">
<li>module:
The module object</li>
</ul>
</dd>
</dl>
</div>
</div>

<div class="method ">
<span class="name">wantModuleTests</span><span class="arg">(self, module)</span>
<div class="doc"><p>Return true if you want the standard test loader to load
tests from this module, false if you want to prevent it from
doing so, and None if you don't care. DO NOT return true if your
plugin will be loading the tests itself!</p>
<dl class="docutils">
<dt>Parameters:</dt>
<dd><ul class="first last simple">
<li>module:
The module object</li>
</ul>
</dd>
</dl>
</div>
</div>


    </div>
  </body>
</html>
  
