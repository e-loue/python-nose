<html>
  <head>
    <title>nose: nose.commands</title>
    <link rel="stylesheet" href="site.css" type="text/css"></link>
  </head>
  <body>
    
    <div id="menu">
      <p>This document covers nose version <b>0.10.0a1</b></p>
      <h2>Documentation</h2><ul><li><a href="writing_plugins.html">Writing Plugins</a></li><li><a href="errorclassplugin.html">ErrorClass Plugins</a></li><li><a href="plugin_interface.html">Plugin Interface</a></li><li><a href="plugin_attrib.html">Builtin Plugin: attrib</a></li><li><a href="plugin_capture.html">Builtin Plugin: capture</a></li><li><a href="plugin_cover.html">Builtin Plugin: cover</a></li><li><a href="plugin_debug.html">Builtin Plugin: debug</a></li><li><a href="plugin_deprecated.html">Builtin Plugin: deprecated</a></li><li><a href="plugin_doctests.html">Builtin Plugin: doctests</a></li><li><a href="plugin_isolate.html">Builtin Plugin: isolate</a></li><li><a href="plugin_failuredetail.html">Builtin Plugin: failuredetail</a></li><li><a href="plugin_prof.html">Builtin Plugin: prof</a></li><li><a href="plugin_skip.html">Builtin Plugin: skip</a></li><li><a href="plugin_testid.html">Builtin Plugin: testid</a></li><li><a href="module_nose.loader.html">Module: nose.loader</a></li><li><a href="module_nose.result.html">Module: nose.result</a></li><li><a href="module_nose.inspector.html">Module: nose.inspector</a></li><li><a href="module_nose.tools.html">Module: nose.tools</a></li><li><a href="module_nose.importer.html">Module: nose.importer</a></li><li><a href="module_nose.suite.html">Module: nose.suite</a></li><li><a href="module_nose.config.html">Module: nose.config</a></li><li><a href="module_nose.core.html">Module: nose.core</a></li><li><a href="module_nose.twistedtools.html">Module: nose.twistedtools</a></li><li><a href="module_nose.util.html">Module: nose.util</a></li><li><a href="module_nose.proxy.html">Module: nose.proxy</a></li><li><a href="module_nose.selector.html">Module: nose.selector</a></li><li><a href="module_nose.case.html">Module: nose.case</a></li><li><a href="module_nose.commands.html">Module: nose.commands</a></li><li><a href="module_nose.exc.html">Module: nose.exc</a></li><li><a href="module_nose.plugins.manager.html">Module: nose.plugins.manager</a></li></ul>
      <p>Last update: <b>Tue Jun 26 16:54:07 2007</b></p>
    </div>
    
    <div id="main">
      <h1>nose: nose.commands</h1>
      
      <p>You can run tests using the <cite>nosetests</cite> setuptools command:</p>
<pre class="literal-block">
python setup.py nosetests
</pre>
<p>This command has a few benefits over the standard <cite>test</cite> command: all nose
plugins are supported, and you can configure the test run with both command
line arguments and settings in your setup.cfg file.</p>
<p>To configure the <cite>nosetests</cite> command, add a [nosetests] section to your
setup.cfg. The [nosetests] section can contain any command line arguments that
nosetests supports. The differences between issuing an option on the command
line and adding it to setup.cfg are:</p>
<blockquote>
<ul class="simple">
<li>In setup.cfg, the -- prefix must be excluded</li>
<li>In setup.cfg, command line flags that take no arguments must be given an
argument flag (1, T or TRUE for active, 0, F or FALSE for inactive)</li>
</ul>
</blockquote>
<p>Here's an example [nosetests] setup.cfg section:</p>
<pre class="literal-block">
[nosetests]
verbosity=1
detailed-errors=1
with-coverage=1
cover-package=nose
debug=nose.loader
pdb=1
pdb-failures=1
</pre>
<p>If you commonly run nosetests with a large number of options, using
the nosetests setuptools command and configuring with setup.cfg can
make running your tests much less tedious. (Note that the same options
and format supported in setup.cfg are supported in all other config
files, and the nosetests script will also load config files.)</p>
<p>Another reason to run tests with the command is that the command will
install packages listed in your <cite>tests_require</cite>, as well as doing a
complete build of your package before running tests. For packages with
dependencies or that build C extensions, using the setuptools command
can be more convenient than building by hand and running the nosetests
script.</p>
<h2>Classes</h2>
<a name="nosetests"></a><div class="cls section"><span class="cls name">nosetests</span> (setuptools.Command)<div class="cls doc"><h3>Methods</h3><div class="method section inherited"><span class="method name">__init__<span class="args">(self, dist, **kw)</span></span><span class="method inherited">(FIXME: inherited from Command)</span><div class="method doc"></div></div><div class="method section inherited"><span class="method name">_ensure_stringlike<span class="args">(self, option, what, default=None)</span></span><span class="method inherited">(FIXME: inherited from Command)</span><div class="method doc"></div></div><div class="method section inherited"><span class="method name">_ensure_tested_string<span class="args">(self, option, tester, what, error_fmt, default=None)</span></span><span class="method inherited">(FIXME: inherited from Command)</span><div class="method doc"></div></div><div class="method section inherited"><span class="method name">announce<span class="args">(self, msg, level=1)</span></span><span class="method inherited">(FIXME: inherited from Command)</span><div class="method doc"><p>If the current verbosity level is of greater than or equal to
'level' print 'msg' to stdout.</p>
</div></div><div class="method section inherited"><span class="method name">copy_file<span class="args">(self, infile, outfile, preserve_mode=1, preserve_times=1, link=None, level=1)</span></span><span class="method inherited">(FIXME: inherited from Command)</span><div class="method doc"><p>Copy a file respecting verbose, dry-run and force flags.  (The
former two default to whatever is in the Distribution object, and
the latter defaults to false for commands that don't define it.)</p>
</div></div><div class="method section inherited"><span class="method name">copy_tree<span class="args">(self, infile, outfile, preserve_mode=1, preserve_times=1, preserve_symlinks=0, level=1)</span></span><span class="method inherited">(FIXME: inherited from Command)</span><div class="method doc"><p>Copy an entire directory tree respecting verbose, dry-run,
and force flags.</p>
</div></div><div class="method section inherited"><span class="method name">debug_print<span class="args">(self, msg)</span></span><span class="method inherited">(FIXME: inherited from Command)</span><div class="method doc"><p>Print 'msg' to stdout if the global DEBUG (taken from the
DISTUTILS_DEBUG environment variable) flag is true.</p>
</div></div><div class="method section inherited"><span class="method name">dump_options<span class="args">(self, header=None, indent='')</span></span><span class="method inherited">(FIXME: inherited from Command)</span><div class="method doc"></div></div><div class="method section inherited"><span class="method name">ensure_dirname<span class="args">(self, option)</span></span><span class="method inherited">(FIXME: inherited from Command)</span><div class="method doc"></div></div><div class="method section inherited"><span class="method name">ensure_filename<span class="args">(self, option)</span></span><span class="method inherited">(FIXME: inherited from Command)</span><div class="method doc"><p>Ensure that 'option' is the name of an existing file.</p>
</div></div><div class="method section inherited"><span class="method name">ensure_finalized<span class="args">(self)</span></span><span class="method inherited">(FIXME: inherited from Command)</span><div class="method doc"></div></div><div class="method section inherited"><span class="method name">ensure_string<span class="args">(self, option, default=None)</span></span><span class="method inherited">(FIXME: inherited from Command)</span><div class="method doc"><p>Ensure that 'option' is a string; if not defined, set it to
'default'.</p>
</div></div><div class="method section inherited"><span class="method name">ensure_string_list<span class="args">(self, option)</span></span><span class="method inherited">(FIXME: inherited from Command)</span><div class="method doc"><p>Ensure that 'option' is a list of strings.  If 'option' is
currently a string, we split it either on /,s*/ or /s+/, so
&quot;foo bar baz&quot;, &quot;foo,bar,baz&quot;, and &quot;foo,   bar baz&quot; all become
[&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;].</p>
</div></div><div class="method section inherited"><span class="method name">execute<span class="args">(self, func, args, msg=None, level=1)</span></span><span class="method inherited">(FIXME: inherited from Command)</span><div class="method doc"></div></div><div class="method section"><span class="method name">finalize_options<span class="args">(self)</span></span><div class="method doc"><p>nothing to do here</p>
</div></div><div class="method section inherited"><span class="method name">get_command_name<span class="args">(self)</span></span><span class="method inherited">(FIXME: inherited from Command)</span><div class="method doc"></div></div><div class="method section inherited"><span class="method name">get_finalized_command<span class="args">(self, command, create=1)</span></span><span class="method inherited">(FIXME: inherited from Command)</span><div class="method doc"><p>Wrapper around Distribution's 'get_command_obj()' method: find
(create if necessary and 'create' is true) the command object for
'command', call its 'ensure_finalized()' method, and return the
finalized command object.</p>
</div></div><div class="method section inherited"><span class="method name">get_sub_commands<span class="args">(self)</span></span><span class="method inherited">(FIXME: inherited from Command)</span><div class="method doc"><p>Determine the sub-commands that are relevant in the current
distribution (ie., that need to be run).  This is based on the
'sub_commands' class attribute: each tuple in that list may include
a method that we call to determine if the subcommand needs to be
run for the current distribution.  Return a list of command names.</p>
</div></div><div class="method section"><span class="method name">initialize_options<span class="args">(self)</span></span><div class="method doc"><p>create the member variables, but change hyphens to underscores</p>
</div></div><div class="method section inherited"><span class="method name">make_archive<span class="args">(self, base_name, format, root_dir=None, base_dir=None)</span></span><span class="method inherited">(FIXME: inherited from Command)</span><div class="method doc"></div></div><div class="method section inherited"><span class="method name">make_file<span class="args">(self, infiles, outfile, func, args, exec_msg=None, skip_msg=None, level=1)</span></span><span class="method inherited">(FIXME: inherited from Command)</span><div class="method doc"><p>Special case of 'execute()' for operations that process one or
more input files and generate one output file.  Works just like
'execute()', except the operation is skipped and a different
message printed if 'outfile' already exists and is newer than all
files listed in 'infiles'.  If the command defined 'self.force',
and it is true, then the command is unconditionally run -- does no
timestamp checks.</p>
</div></div><div class="method section inherited"><span class="method name">mkpath<span class="args">(self, name, mode=511)</span></span><span class="method inherited">(FIXME: inherited from Command)</span><div class="method doc"></div></div><div class="method section inherited"><span class="method name">move_file<span class="args">(self, src, dst, level=1)</span></span><span class="method inherited">(FIXME: inherited from Command)</span><div class="method doc"><p>Move a file respectin dry-run flag.</p>
</div></div><div class="method section inherited"><span class="method name">reinitialize_command<span class="args">(self, command, reinit_subcommands=0, **kw)</span></span><span class="method inherited">(FIXME: inherited from Command)</span><div class="method doc"></div></div><div class="method section"><span class="method name">run<span class="args">(self)</span></span><div class="method doc"><p>ensure tests are capable of being run, then
run nose.main with a reconstructed argument list</p>
</div></div><div class="method section inherited"><span class="method name">run_command<span class="args">(self, command)</span></span><span class="method inherited">(FIXME: inherited from Command)</span><div class="method doc"><p>Run some other command: uses the 'run_command()' method of
Distribution, which creates and finalizes the command object if
necessary and then invokes its 'run()' method.</p>
</div></div><div class="method section inherited"><span class="method name">set_undefined_options<span class="args">(self, src_cmd, *option_pairs)</span></span><span class="method inherited">(FIXME: inherited from Command)</span><div class="method doc"><p>Set the values of any &quot;undefined&quot; options from corresponding
option values in some other command object.  &quot;Undefined&quot; here means
&quot;is None&quot;, which is the convention used to indicate that an option
has not been changed between 'initialize_options()' and
'finalize_options()'.  Usually called from 'finalize_options()' for
options that depend on some other command rather than another
option of the same command.  'src_cmd' is the other command from
which option values will be taken (a command object will be created
for it if necessary); the remaining arguments are
'(src_option,dst_option)' tuples which mean &quot;take the value of
'src_option' in the 'src_cmd' command object, and copy it to
'dst_option' in the current command object&quot;.</p>
</div></div><div class="method section inherited"><span class="method name">spawn<span class="args">(self, cmd, search_path=1, level=1)</span></span><span class="method inherited">(FIXME: inherited from Command)</span><div class="method doc"><p>Spawn an external command respecting dry-run flag.</p>
</div></div><div class="method section inherited"><span class="method name">warn<span class="args">(self, msg)</span></span><span class="method inherited">(FIXME: inherited from Command)</span><div class="method doc"></div></div><h3>Attributes</h3><div class="attr section"><span class="attr name">_nosetests__config</span><span class="attr value">Default value: Config(addPaths=True, args=(), configSection='nosetests', debug=None, debugLog=None, env={}, exclude=None, files=['/home/jhp/.noserc'], getTestCaseNamesCompat=False, ignoreFiles=(<_sre.SRE_Pattern object at 0x2b0aaf36dab0>, <_sre.SRE_Pattern object at 0x2b0aaf36da40>, <_sre.SRE_Pattern object at 0x2b0aafc46b30>), include=None, includeExe=False, logStream=<open file '<stderr>', mode 'w' at 0x2b0aad495210>, loggingConfig=None, options=(), parser=<optparse.OptionParser instance at 0x2b0aaec9b560>, plugins=<nose.plugins.manager.DefaultPluginManager object at 0x2b0aaf375690>, runOnInit=True, srcDirs=('lib', 'src'), stopOnError=False, stream=<open file '<stderr>', mode 'w' at 0x2b0aad495210>, testMatch=<_sre.SRE_Pattern object at 0x2b0aafc74210>, testMatchPat='(?:^|[\\b_\\./-])[Tt]est', testNames=(), verbosity=1, where=(), workingDir=None)</span><div class="attr doc"></div></div><div class="attr section"><span class="attr name">_nosetests__parser</span><span class="attr value">Default value: <optparse.OptionParser instance at 0x2b0aaec9b560></span><div class="attr doc"></div></div><div class="attr section inherited"><span class="attr name">command_consumes_arguments</span><span class="attr value">Default value: False</span><div class="attr doc"></div></div><div class="attr section"><span class="attr name">description</span><span class="attr value">Default value: Run unit tests using nosetests</span><div class="attr doc"></div></div><div class="attr section inherited"><span class="attr name">sub_commands</span><span class="attr value">Default value: []</span><div class="attr doc"></div></div><div class="attr section"><span class="attr name">user_options</span><span class="attr value">Default value: [('version', 'V', 'Output nose version and exit'), ('plugins', 'p', 'Output list of available plugins and exit. Combine with higher verbosity for greater detail'), ('verbosity=', None, 'Set verbosity; --verbosity=2 is the same as -v'), ('quiet=', 'q', ''), ('config=', 'c', 'Load configuration from config file(s). May be specified multiple times; in that case, all config files will be loaded and combined'), ('where=', 'w', 'Look for tests in this directory. May be specified multiple times. The first directory passed will be used as the working directory, in place of the current working directory, which is the default. Others will be added to the list of tests to execute. [NOSE_WHERE]'), ('match=', 'm', 'Use this regular expression to find tests [NOSE_TESTMATCH]'), ('tests=', None, 'Run these tests (comma-separated list). This argument is useful mainly from configuration files; on the command line, just pass the tests to run as additional arguments with no switch.'), ('debug=', 'l', 'Activate debug logging for one or more systems. Available debug loggers: nose, nose.importer, nose.inspector, nose.plugins, nose.result and nose.selector. Separate multiple names with a comma.'), ('debug-log=', None, 'Log debug messages to this file (default: sys.stderr)'), ('logging-config=', None, 'Load logging config from this file -- bypasses all other logging config settings.'), ('exclude=', 'e', "Don't run tests that match regular expression [NOSE_EXCLUDE]"), ('include=', 'i', 'Also run tests that match regular expression [NOSE_INCLUDE]'), ('stop', 'x', 'Stop running tests after the first error or failure'), ('no-path-adjustment=', 'P', "Don't make any changes to sys.path when loading tests [NOSE_NOPATH]"), ('exe', None, 'Look for tests in python modules that are executable. Normal behavior is to exclude executable modules, since they may not be import-safe [NOSE_INCLUDE_EXE]'), ('noexe=', None, 'DO NOT look for tests in python modules that are executable. (The default on the windows platform is to do so.)'), ('with-html-output', None, 'Enable plugin HtmlOutput: Output test results as ugly, unstyled html.\n     [NOSE_WITH_HTML-OUTPUT]'), ('with-watch', None, 'Enable plugin NoseWatch: watch failing tests, re-testing when modified\n     [NOSE_WITH_WATCH]'), ('with-stopwatch', None, 'Enable plugin Stopwatch: (no help available) [NOSE_WITH_STOPWATCH]'), ('faster-than=', None, 'Run only tests that are faster than FASTER_THAN seconds.'), ('stopwatch-file=', None, 'Store test timing results in this file.'), ('with-figleafsections', None, 'Enable plugin FigleafSections: (no help available) [NOSE_WITH_FIGLEAFSECTIONS]'), ('figleaf-file=', None, 'Store figleaf section coverage in this file'), ('decorator-file=', None, 'Apply attributes in this file to matching functions, classes, and methods'), ('with-tty', None, 'Enable plugin NoseTTY: run nosetests more interactively [NOSE_WITH_TTY]'), ('tty', None, 'Enable plugin NoseTTY: run nosetests more interactively [NOSE_TTY]'), ('tty-editor=', None, 'editor program [NOSE_TTY_EDITOR or EDITOR] (currently: `None`)'), ('tty-edit-cmd=', None, 'template to invoke edit command.  [NOSE_TTY_EDIT_CMD] (currently: `%(editor)s %(filename)s --line %(lineno)s`)'), ('attr=', 'a', 'Run only tests that have attributes specified by ATTR [NOSE_ATTR]'), ('eval-attr=', 'A', 'Run only tests for whose attributes the Python expression EXPR evaluates to True [NOSE_EVAL_ATTR]'), ('nocapture=', 's', "Don't capture stdout (any stdout output will be printed immediately) [NOSE_NOCAPTURE]"), ('with-coverage', None, "Enable plugin Coverage: \nIf you have Ned Batchelder's coverage module installed, you may\nactivate a coverage report. The coverage report will cover any\npython source module imported after the start of the test run, excluding\nmodules that match testMatch. If you want to include those modules too,\nuse the --cover-tests switch, or set the NOSE_COVER_TESTS environment\nvariable to a true value. To restrict the coverage report to modules from\na particular package or packages, use the --cover-packages switch or the\nNOSE_COVER_PACKAGES environment variable.\n [NOSE_WITH_COVERAGE]"), ('cover-package=', None, 'Restrict coverage output to selected packages [NOSE_COVER_PACKAGE]'), ('cover-erase', None, 'Erase previously collected coverage statistics before run'), ('cover-tests', None, 'Include test modules in coverage report [NOSE_COVER_TESTS]'), ('cover-inclusive', None, 'Include all python files under working directory in coverage report.  Useful for discovering holes in test coverage if not all files are imported by the test suite. [NOSE_COVER_INCLUSIVE]'), ('pdb', None, 'Drop into debugger on errors'), ('pdb-failures', None, 'Drop into debugger on failures'), ('no-deprecated', None, 'Disable special handling of DeprecatedTest exceptions.'), ('with-doctest', None, 'Enable plugin Doctest: \nActivate doctest plugin to find and run doctests in non-test modules.\n [NOSE_WITH_DOCTEST]'), ('doctest-tests', None, 'Also look for doctests in test modules [NOSE_DOCTEST_TESTS]'), ('doctest-extension=', None, 'Also look for doctests in files with this extension [NOSE_DOCTEST_EXTENSION]'), ('with-isolation', None, 'Enable plugin IsolationPlugin: \nActivate the isolation plugin to isolate changes to external\nmodules to a single test module or package. The isolation plugin\nresets the contents of sys.modules after each test module or\npackage runs to its state before the test. PLEASE NOTE that this\nplugin should not be used with the coverage plugin in any other case\nwhere module reloading may produce undesirable side-effects.\n [NOSE_WITH_ISOLATION]'), ('detailed-errors', 'd', 'Add detail to error output by attempting to evaluate failed asserts [NOSE_DETAILED_ERRORS]'), ('with-profile', None, 'Enable plugin Profile: \nUse this plugin to run tests using the hotshot profiler. \n [NOSE_WITH_PROFILE]'), ('profile-sort=', None, 'Set sort order for profiler output'), ('profile-stats-file=', None, 'Profiler stats file; default is a new temp file on each run'), ('profile-restrict=', None, 'Restrict profiler output. See help for pstats.Stats for details'), ('no-skip', None, 'Disable special handling of SkipTest exceptions.'), ('with-id', None, "Enable plugin TestId: \nActivate to add a test id (like #1) to each test name output. After\nyou've run once to generate test ids, you can re-run individual\ntests by activating the plugin and passing the ids (with or\nwithout the # prefix) instead of test names.\n [NOSE_WITH_ID]"), ('id-file=', None, 'Store test ids found in test runs in this file.')]</span><div class="attr doc"></div></div></div></div><h2>Functions</h2>
<a name="get_user_options"></a><div class="func section"><span class="func name">get_user_options<span class="args">(parser)</span></span><div class="func doc"><p>convert a optparse option list into a distutils option tuple list</p>
</div></div><h2>Attributes</h2>
<a name="option_blacklist"></a><div class="attr section"><span class="attr name">option_blacklist</span><pre class="attr value">Default value: [&#39;help&#39;, &#39;verbose&#39;]</pre><div class="attr doc"></div></div>

    </div>
  </body>
</html>
  
